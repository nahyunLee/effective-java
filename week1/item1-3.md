# item1 - 생성자 대신 정적 팩토리 메서드를 고려하라
1. 정적 팩터리 메서드 (stataic factory method)
* 클래스의 인스턴스를 반환하는 단순한 정적 메서드
2. 정적 팩터리 메서드가 생성자보다 좋은 장점
* 이름을 가질 수 있다.
    * 이름을 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있다.
    * 생성자가 어떤 역할을 하는지 정확히 기억하기 어려워 엉뚱한 호출하는 실수를 막을 수 있다. - 생성자는 의미를 알기 어렵다.
* 호출될 떄마다 인스턴스를 새로 생성하지 않아도 된다.
    * 인스턴스를 통제하면 클래스를 싱글턴으로 만들 수도, 인스턴스화 불가로 만들 수도 있다.
* 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
* 내가 생각하는 장정
    * 객체를 생성할 떄, 객체가 초기에 가져야 하는 값이 정해져 있는 경우가 있는데 이럴때 초기 값을 강제할 수 있어서 좋음
    * 예를 들어, 게임을 시작할 때 '플레이어'라는 객체는 돈이 0원인 채로 시작한다.
    * 이럴 떄 '플레이어'객체를 만들 때, 인자로 0이라는 값을 생성자 인자로 주지 않고 정적 팩터리 메서드에서 한번에 초기화할 수 있다.
     ```java
     class Player{
        private String name;
        private long money;
        
        private Player(String name, long money){
            this.name = name;
            this.money = money;
        }
        
        public static Player createPlayer(String name){
             retrun Player(name, 0L);
        }
       ```

# item2 - 생성자에 매개변수가 많다면 빌더를 고려하라
1. 점층적 생성자 패턴
* 원하는 매개변수들을 포함한 생성자들을 만드는 것
* 점층적 생성자 패턴도 쓸 수 있지만, 매개변수 개수가 ㅁ낳아지면 클라이언트 코드를 작성하거나 읽기 어렵다
2. 자바빈즈 패턴
* 객체 하나를 만드려면 메서드 여러개를 호출해야함.
* 객체가 생성되기 전까지는 일관성이 무너진 상태에 놓여짐
    * 버그를 심은 코드와 그 버그 때문에 런타임에 문제를 겪는 코드가 물리적으로 멀리 떨어져 있을 것이므로 디버깅도 어렵다.
* 클래스를 불변으로 만들 수 없음 (세터 다 열려있으니꼐 ㅠ.ㅠ)
    * freezing : 생성이 끝난 객체를 수동으로 얼리고, 얼리기 전까지 사용할 수 없도록 한다. -> 다루기 어려워서 거읮 ㅏㄹ 안씀
3. 빌더 패턴
* 빌더의 세터 메서들은 빌더 자신을 호출하기 반환하기 때문에 연쇄적으로 호출할 수 있다.
* method chaining, fluent API : 메서드 호출이 흐르듯 연걸되는 것
* python, scala에 있는 명명된 선택적 매개변수(nmed optional parameters)를 흉내낸 것.
* 잘못된 매개변수를 일찍 발견하려면 빌더의 생성자와 메서드에서 입력 매개변수를 검사하고, build 메서드가 호출하는 생성자에서 여러 매개변수에 걸친 불변식을 검사하자.
* 계층적으로 설계된 클래스와 함꼐 쓰기 좋다.
* 공변환 타이핑(covariant return typing)
    * 하위 클래스의 메서드가 상위 클래스의 메서드가 정의한 반환 타입이 아닌, 그 하위 타입을 반환하는 기능
* 빌더 생성 비용이 크지는 않지만 성능에 민감한 상황에서는 문제가 될 수 있다.
* 점층적 생성자 패턴보다는 코드가 장황해서 매개변수가 4개 이상은 되어야 값어치를 한다.-> 하지만 API는 시간이 지날수록 커지므로 처음부터 빌더로 시작하는 편이 좋을 떄도 있다

# item 3 - private 생성자나 열거타입으로 싱글턴임을 보장하라
* 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다. -> mock구현으로 대체할 수 없기 때문
* 만드는 방법 : 두 방식 모두 private으로 감춰두고 유일한 인스턴스에 접근하는 수단
    * public static 멤버가 Final 필드인 방식
        * private 생성자에 접근을 못함
        * 권한이 있는 클라이언트가 리플랙션 api를 사용하여 private 생성자를 호출 할 수 있음 -> 생성자를 수정하여 두번째 객체가 생성하려고 할 때 예외 던지도록 하면 됨
        * 장점 : 간결함, 싱글턴 클래스임이 api에 명백히 나타남,
    * 정적 팩터리 메서드를 public static 멤버로 제공ㅇ
        * 장점 : 싱글턴이 아니게 바꿀 수 있음, 정적 팩토리를 제네릭 싱글턴 팩터리로 만들 수 잇음. 정적 팩토리의 메서드 참조를 공급자라고 사용할 수 있음
        * serilize할 때, 인스턴스 필드를 transient선언하고 readResolve메서드를 제공하지 않으면 역직렬화할 때마다 새로운 인스턴스가 생성된다
    * 원소가 하나인 enum타입을 선언하는 것
        * 더 간결하고, 추가 없이 직렬화 가능.
        * 어색하나, 대부분 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법
        * 만드려는 싱글턴이 Enum외에 다른 클래스를 상속해야 한다면 쓸 수 없음
        
* 불변(immutable, immutalbililty)
    * 어떠한 변경도 허용하지 않음.
    * ex. String 불변식 (invariant)
    * 프로그램이 실행되는 동안, 혹은 정해진 기간 동안 반드시 만족해야= 하는 조건ㅇ.
    * 변경을 허용할 수 있으나. 주어진 조건내에서만 허용.
